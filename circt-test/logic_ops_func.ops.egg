(include "../src/base.egg")

;;;; Additional Type Definitions ;;;;
(function I3 () Type)

;;;; Arith Dialect Functions ;;;;
(function arith_constant (AttrPair Type) Op)
(function arith_cmpi (AttrPair Op Op Type) Op)
(function arith_extui (Op Type Type) Op)
(function arith_ori (Op Op Type) Op)
(function arith_andi (Op Op Type) Op)

;;;; Func Dialect Functions ;;;;
(function func_return (OpVec TypeVec) Op)

;; OPS HERE ;;
; logic_ops_func.func
(let op0 (Value 0 (I4)))
(let op1 (Value 1 (I4)))
(let op2 (arith_constant (NamedAttr "value" (IntegerAttr 0 (Int3))) (Int3)))
(let op3 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I4))) (I4)))
(let op4 (arith_cmpi op0 op3 (NamedAttr "predicate" (IntegerAttr 1 (I64))) (I1)))
(let op5 (Value 5 (I4)))
(let op6 (arith_constant (NamedAttr "value" (IntegerAttr 1 (I4))) (I4)))
(let op7 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I4))) (I4)))
(let op8 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I4))) (I4)))
(let op9 (arith_ori op0 op1 (I4)))
(let op10 (arith_andi op0 op9 (I4)))
(let op11 (Value 11 (None)))

;; RULES HERE ;;
(ruleset arith_rules)

;; Basic Boolean algebra rules for arith operations
;; Idempotent: a & a = a
(rewrite (arith_andi ?x ?x ?t) ?x :ruleset arith_rules)

;; Idempotent: a | a = a  
(rewrite (arith_ori ?x ?x ?t) ?x :ruleset arith_rules)

;; Absorption: a & (a | b) = a
(rewrite (arith_andi ?a (arith_ori ?a ?b ?t1) ?t2) ?a :ruleset arith_rules)

;; Absorption: a | (a & b) = a
(rewrite (arith_ori ?a (arith_andi ?a ?b ?t1) ?t2) ?a :ruleset arith_rules)

;; Commutative property for AND
(rewrite (arith_andi ?a ?b ?t) (arith_andi ?b ?a ?t) :ruleset arith_rules)

;; Commutative property for OR
(rewrite (arith_ori ?a ?b ?t) (arith_ori ?b ?a ?t) :ruleset arith_rules)

(run-schedule (saturate arith_rules))

;; EXTRACTS HERE ;; 
