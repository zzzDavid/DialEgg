## Variadic Operations in DialEgg (2025-10-07)

### Overview
- **Problem**: DialEgg previously required defining many op signatures to cover different operand counts (e.g., `comb_add_2`, `comb_add_3`, ...), which is infeasible for ops that may take up to thousands of operands.
- **Solution**: Introduce first-class support for variadic operands in the Egg interface and in DialEggâ€™s MLIR<->Egg conversion, avoiding explosion of arity-specific variants.

### Key Idea
- Extend `EgglogOpDef` with variadic metadata and support a new operand marker in egg function signatures:
  - `OpVec` marks a variadic tail of operands carried as a single vector argument.
  - The parser remains tolerant to older ad-hoc markers (`Ops`, `Op*`, `Ops*`, `Op+`, `Ops+`) but `OpVec` is the preferred and supported mechanism.

### What Changed
1) `EgglogOpDef` supports variadic ops

```cpp
// src/Egglog.h
struct EgglogOpDef {
    std::string str;
    std::string dialect, name, version;
    std::vector<std::string> args;

    size_t nOperands;
    size_t nAttributes;
    size_t nRegions;
    size_t nResults;

    size_t cost = 1;

    // NEW: variadic metadata
    bool hasVariadicOperands = false; // op can accept variable # of operands
    size_t minOperands = 0;           // minimum number of operands required
    bool usesOpVec = false;           // variadic tail encoded as an OpVec

    bool matches(mlir::Operation* op) const {
        if (op->getName().getStringRef() != mlirName()) return false;
        if (!hasVariadicOperands) {
            if (op->getNumOperands() != nOperands) return false;
        } else {
            if (op->getNumOperands() < minOperands) return false;
        }
        return op->getNumResults() == nResults;
    }
};
```

2) Variadic parsing from egg `(function ...)`

```cpp
// src/Egglog.cpp (excerpt from EgglogOpDef::parseOpFunction)
size_t nOperands = 0, nAttributes = 0, nRegions = 0, nResults = 0;
bool hasVariadicOperands = false, usesOpVec = false;
size_t minOperands = 0;

for (std::string_view arg : args) {
    if (arg == "Op") {
        if (!hasVariadicOperands) { nOperands++; minOperands++; }
    } else if (arg == "OpVec" || arg == "Ops" || arg == "Op*" ||
               arg == "Ops*" || arg == "Op+" || arg == "Ops+") {
        hasVariadicOperands = true;
        if (arg == "OpVec") usesOpVec = true;
        if (!arg.empty() && arg.back() == '+') minOperands++;
    } else if (arg == "AttrPair") {
        nAttributes++;
    } else if (arg == "Region") {
        nRegions++;
    } else if (arg == "Type") {
        nResults++;
    }
}

return EgglogOpDef{ /* ... */, .nOperands = nOperands, /* ... */
    .hasVariadicOperands = hasVariadicOperands,
    .minOperands = minOperands,
    .usesOpVec = usesOpVec,
};
```

3) Parsing Egg ops with a variadic tail

```cpp
// src/Egglog.cpp (excerpt from Egglog::parseOperation)
std::vector<mlir::Value> operands;
size_t totalTokensAfterName = split.size() - 1;
size_t trailingCount = egglogOpDef.nAttributes + egglogOpDef.nRegions + egglogOpDef.nResults;

if (egglogOpDef.hasVariadicOperands && egglogOpDef.usesOpVec) {
    // Parse fixed leading operands
    for (size_t i = 0; i < egglogOpDef.nOperands; i++, index++) {
        // parse each operand token (Value or nested op)
    }
    // Expand the next token as an OpVec list
    if (index + 1 < split.size() - trailingCount) {
        auto vec = splitExpression(split[index + 1]); // (vec-of ...)
        for (size_t vi = 1; vi < vec.size(); ++vi) {
            // parse each vec element as an operand
        }
        index++; // consumed the OpVec token
    }
} else {
    // Non-OpVec variadic: consume all operand tokens before trailing section
    size_t availableOperandTokens = (totalTokensAfterName > trailingCount)
        ? (totalTokensAfterName - trailingCount) : 0;
    size_t operandsToParse = egglogOpDef.hasVariadicOperands
        ? availableOperandTokens
        : egglogOpDef.nOperands;
    for (size_t i = 0; i < operandsToParse; i++, index++) {
        // parse each operand token
    }
}
```

4) Emitting Egg for variadic ops with `OpVec`

```cpp
// src/Egglog.cpp (excerpt from Egglog::eggifyOperation)
size_t operandCount = op->getNumOperands();
if (egglogOpDef.hasVariadicOperands && egglogOpDef.usesOpVec) {
    // Emit fixed leading operands
    size_t fixed = egglogOpDef.nOperands;
    for (size_t i = 0; i < std::min(fixed, operandCount); i++) {
        // emit operand i
    }
    // Emit the rest as a single OpVec list
    ss << " (vec-of";
    for (size_t i = fixed; i < operandCount; i++) {
        // emit operand i
    }
    ss << ")";
} else {
    // Emit all operands positionally
}
```

5) Backward compatibility in op lookup

```cpp
// src/Egglog.cpp (excerpt from Egglog::findEgglogOpDef)
// Try name-only key first; then backward-compatible arity suffixes
std::string opNameWithNumOperands = opName + "_" + std::to_string(op->getNumOperands());
if (auto it = supportedEgglogOps.find(opNameWithNumOperands); it != supportedEgglogOps.end()) {
    if (it->second.matches(op)) return it->second;
}
for (const auto& [name, def] : supportedEgglogOps) {
    if (name.rfind(opName + "_", 0) == 0 && def.matches(op)) return def;
}
```

### How to Author Variadic Egg Functions
- Preferred form: use `OpVec` to carry the variadic tail as a single vector argument.

```egglog
(function comb_concat (Op OpVec Type) Op)
```

This encodes one fixed leading operand (`Op`), followed by a variadic tail (`OpVec`), and finally the result type (`Type`).

The emitted/parsed operation will look like:

```egglog
(comb_concat op0 (vec-of op1 op2 op3) (Int 32))
```

For tolerant parsing, `Ops`, `Op*`, `Op+`, etc. are recognized, but they are a compatibility affordance; they do not materialize into an `OpVec` list on emission.

### Example Test Added
Files:
- `test/circt/concatvar/concatvar.egg`
- `test/circt/concatvar/concatvar.mlir`

Egg function:

```egglog
(include "../../../src/base.egg")

;;;; comb dialect ;;;;
(function comb_concat (Op OpVec Type) Op)

;;;; hw dialect ;;;;
(function hw_output (Op) Op)

;; OPS HERE ;;
;; RULES HERE ;;
(ruleset rules)
(run-schedule (saturate rules))
;; EXTRACTS HERE ;;
```

MLIR:

```mlir
module {
  hw.module @ConcatVar(in %a : i8, in %b : i8, in %c : i8, out out : i24) {
    %0 = comb.concat %a, %b, %c : i8, i8, i8
    hw.output %0 : i24
  }
}
```

Running under the `aspen` environment (with `egglog` on PATH) prints the module successfully, confirming variadic parsing and emission are working end-to-end.

### Notes and Compatibility
- Existing fixed-arity definitions continue to work unchanged.
- Variadic support is opt-in via `OpVec` in the egg function; use it for ops with unbounded or large operand lists (e.g., `comb.concat`, `comb.add` over many inputs, etc.).
- Integer type stringification was normalized to `(Int <width>)` (and `(SInt <width>)`, `(UInt <width>)`) to match egg expectations.

### Outcome
- Variadic operations are now supported without generating an explosion of arity-specific op variants, making DialEgg scalable and simpler to maintain.


