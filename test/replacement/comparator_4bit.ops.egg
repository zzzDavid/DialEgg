(include "base.egg")

;;;; Additional Type Definitions ;;;;
(function Int2 () Type)
(function Int3 () Type)
(function Int5 () Type)
(function Int6 () Type)
(function Int9 () Type)
(function Int10 () Type)
(function Int18 () Type)
(function Int128() Type)
(function Int256() Type)
(function Int384() Type)
(function Int512() Type)
(function Int2048 () Type)

;;;; comb dialect ;;;;
(function comb_mux (Op Op Op Type) Op)
(function comb_and (Op OpVec Type) Op)
(function comb_or (Op OpVec Type) Op)
(function comb_xor (Op OpVec Type) Op)
(function comb_replicate (Op Type) Op)
(function comb_concat (Op OpVec Type) Op)
(function comb_icmp (Op Op AttrPair Type) Op)
(function comb_extract (Op AttrPair Type) Op)
(function comb_add (Op OpVec Type) Op)
(function comb_sub (Op OpVec Type) Op)
(function comb_mul (Op Op Type) Op)

;;;; hw dialect ;;;;
(function hw_output (Op OpVec) Op)
(function hw_constant (AttrPair Type) Op)

;;;; seq dialect ;;;;
(function seq_to_clock (Op Type) Op)
(function seq_firreg (Op OpVec AttrPair Type) Op)

;;;; RootNode for extraction ;;;;
(datatype Root
  (RootNode Op)
)

;; OPS HERE ;;
; comparator_4bit_hw.module
(let op0 (Value 0 (I1)))
(let op1 (Value 1 (I4)))
(let op2 (Value 2 (I4)))
(let op3 (hw_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)))
(let op4 (hw_constant (NamedAttr "value" (IntegerAttr 0 (I4))) (I4)))
(let op5 (hw_constant (NamedAttr "value" (IntegerAttr 0 (I1))) (I1)))
(let op6 (Value 6 (I4)))
(let op7 (comb_concat op5 (vec-push (vec-empty) op6) (Int5)))
(let op8 (Value 8 (I4)))
(let op9 (comb_concat op5 (vec-push (vec-empty) op8) (Int5)))
(let op10 (comb_sub op7 (vec-push (vec-empty) op9) (Int5)))
(let op11 (comb_extract op10 (NamedAttr "lowBit" (IntegerAttr 4 (I32))) (I1)))
(let op12 (comb_extract op10 (NamedAttr "lowBit" (IntegerAttr 0 (I32))) (I4)))
(let op13 (comb_xor op11 (vec-push (vec-empty) op3) (I1)))
(let op14 (comb_icmp op12 op4 (NamedAttr "predicate" (IntegerAttr 1 (I64))) (I1)))
(let op15 (comb_and op13 (vec-push (vec-empty) op14) (I1)))
(let op16 (comb_icmp op6 op8 (NamedAttr "predicate" (IntegerAttr 0 (I64))) (I1)))
(let op17 (seq_to_clock op0 (OpaqueType "!seq.clock" "seq.clock")))
(let op18 (seq_firreg op15 (vec-push (vec-empty) op17) (NamedAttr "name" (StringAttr "A_greater")) (I1)))
(let op19 (seq_firreg op16 (vec-push (vec-empty) op17) (NamedAttr "name" (StringAttr "A_equal")) (I1)))
(let op20 (seq_firreg op11 (vec-push (vec-empty) op17) (NamedAttr "name" (StringAttr "A_less")) (I1)))
(let op21 (hw_output op18 (vec-push (vec-push (vec-empty) op19) op20)))

;; RULES HERE ;;
(ruleset rules)

; Rule 1: Diff-based inequality → register inequality (iteration 1)
; diff != 0 -> A_reg != B_reg
; op14 in the original design computes diff != 0, but this can be
; replaced with direct comparison of the registers
(rewrite
    op14
    (comb_icmp op6 op8 (NamedAttr "predicate" (IntegerAttr 1 (I64))) (I1))
    :ruleset rules)

; Rule 2: Borrow bit → unsigned-less-than (iteration 2)
; The borrow bit (op11) from A - B indicates A < B
(rewrite
    op11
    (comb_icmp op6 op8 (NamedAttr "predicate" (IntegerAttr 4 (I64))) (I1))
    :ruleset rules)

; Rule 3: (~borrow) ∧ (diff≠0) → unsigned-greater-than (iterations 1–5)
; op15 = (~cout) && (diff != 0) can be replaced with A_reg > B_reg
(rewrite
    op15
    (comb_icmp op6 op8 (NamedAttr "predicate" (IntegerAttr 2 (I64))) (I1))
    :ruleset rules)

; Rule 4: Equality from inverted inequality (iteration 4)
; A == B -> ~(A != B)
(rewrite
    op16
    (comb_xor
        (comb_icmp op6 op8 (NamedAttr "predicate" (IntegerAttr 1 (I64))) (I1))
        (vec-of op3)
        (I1))
    :ruleset rules)

(run-schedule (saturate rules))

;; EXTRACTS HERE ;;
(let root_op21 (RootNode op21))
