// Generated by CIRCT unknown git version

// Include register initializers in init blocks unless synthesis is set	// <stdin>:36:5
`ifndef RANDOMIZE	// <stdin>:37:5
  `ifdef RANDOMIZE_REG_INIT	// <stdin>:39:7
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS	// <stdin>:43:5
  `ifndef ENABLE_INITIAL_REG_	// <stdin>:45:7
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS
	// <stdin>:50:5
// Standard header to adapt well known macros for register randomization.	// <stdin>:5:5

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.	// <stdin>:6:5
`ifndef RANDOM	// <stdin>:7:5
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.	// <stdin>:11:5
`ifndef INIT_RANDOM	// <stdin>:12:5
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.	// <stdin>:16:5
`ifndef RANDOMIZE_DELAY	// <stdin>:17:5
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.	// <stdin>:21:5
`ifndef INIT_RANDOM_PROLOG_	// <stdin>:22:5
  `ifdef RANDOMIZE	// <stdin>:24:7
    `ifdef VERILATOR	// <stdin>:25:9
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_
module comparator_4bit(	// <stdin>:62:3
  input        clk,	// <stdin>:62:33
  input  [3:0] A,	// <stdin>:62:47
               B,	// <stdin>:62:59
  output       A_greater,	// <stdin>:62:72
               A_equal,	// <stdin>:62:92
               A_less	// <stdin>:62:110
);

  reg [3:0] A_reg;	// <stdin>:66:14
  reg [3:0] B_reg;	// <stdin>:68:14
  reg       A_greater_0;	// <stdin>:71:18
  reg       A_equal_0;	// <stdin>:74:16
  reg       A_less_0;	// <stdin>:77:15
  always @(posedge clk) begin	// <stdin>:79:5
    A_reg <= A;	// <stdin>:80:7
    B_reg <= B;	// <stdin>:81:7
  end // always @(posedge)
  always @(posedge clk) begin	// <stdin>:83:5
    A_greater_0 <= $signed(A_reg) < $signed(B_reg);	// <stdin>:67:10, :69:10, :70:10, :84:7
    A_equal_0 <= A_reg == B_reg;	// <stdin>:67:10, :69:10, :73:10, :85:7
    A_less_0 <= $signed(A_reg) > $signed(B_reg);	// <stdin>:67:10, :69:10, :76:10, :86:7
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_	// <stdin>:88:5
    `ifdef FIRRTL_BEFORE_INITIAL	// <stdin>:90:9
      `FIRRTL_BEFORE_INITIAL	// <stdin>:91:11
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin	// <stdin>:93:9
      automatic logic [31:0] _RANDOM[0:0];	// <stdin>:98:24
      `ifdef INIT_RANDOM_PROLOG_	// <stdin>:94:11
        `INIT_RANDOM_PROLOG_	// <stdin>:95:13
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT	// <stdin>:97:11
        for (logic  i = 1'h0; i < 1'h1; i += 1'h1) begin
          _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;	// <stdin>:100:25, :102:21, :103:15
        end	// <stdin>:64:13, :65:14
        A_reg = _RANDOM[/*Zero width*/ 1'b0][3:0];	// <stdin>:105:18, :106:18, :107:19, :108:13
        B_reg = _RANDOM[/*Zero width*/ 1'b0][7:4];	// <stdin>:105:18, :109:19, :110:19, :111:13
        A_greater_0 = _RANDOM[/*Zero width*/ 1'b0][8];	// <stdin>:105:18, :112:19, :113:19, :114:13
        A_equal_0 = _RANDOM[/*Zero width*/ 1'b0][9];	// <stdin>:105:18, :115:19, :116:19, :117:13
        A_less_0 = _RANDOM[/*Zero width*/ 1'b0][10];	// <stdin>:105:18, :118:19, :119:19, :120:13
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL	// <stdin>:123:9
      `FIRRTL_AFTER_INITIAL	// <stdin>:124:11
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign A_greater = A_greater_0;	// <stdin>:72:10, :128:5
  assign A_equal = A_equal_0;	// <stdin>:75:10, :128:5
  assign A_less = A_less_0;	// <stdin>:78:10, :128:5
endmodule

